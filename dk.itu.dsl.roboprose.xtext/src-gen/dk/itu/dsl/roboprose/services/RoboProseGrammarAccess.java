/*
 * generated by Xtext 2.12.0
 */
package dk.itu.dsl.roboprose.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class RoboProseGrammarAccess extends AbstractGrammarElementFinder {
	
	public class RoboProseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.RoboProse");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRoboProseAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cMyKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cRobotKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cShouldKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cMainAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cMainMainParserRuleCall_1_3_0 = (RuleCall)cMainAssignment_1_3.eContents().get(0);
		private final RuleCall cParagraphDelimiterParserRuleCall_1_4 = (RuleCall)cGroup_1.eContents().get(4);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cListenersAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cListenersEventListenerParserRuleCall_2_0_0 = (RuleCall)cListenersAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final RuleCall cParagraphDelimiterParserRuleCall_2_1_0 = (RuleCall)cGroup_2_1.eContents().get(0);
		private final Assignment cListenersAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cListenersEventListenerParserRuleCall_2_1_1_0 = (RuleCall)cListenersAssignment_2_1_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//RoboProse:
		//	{RoboProse} ('My' 'robot' 'should' main=Main ParagraphDelimiter)? (listeners+=EventListener (ParagraphDelimiter
		//	listeners+=EventListener)* '.')?;
		@Override public ParserRule getRule() { return rule; }
		
		//{RoboProse} ('My' 'robot' 'should' main=Main ParagraphDelimiter)? (listeners+=EventListener (ParagraphDelimiter
		//listeners+=EventListener)* '.')?
		public Group getGroup() { return cGroup; }
		
		//{RoboProse}
		public Action getRoboProseAction_0() { return cRoboProseAction_0; }
		
		//('My' 'robot' 'should' main=Main ParagraphDelimiter)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'My'
		public Keyword getMyKeyword_1_0() { return cMyKeyword_1_0; }
		
		//'robot'
		public Keyword getRobotKeyword_1_1() { return cRobotKeyword_1_1; }
		
		//'should'
		public Keyword getShouldKeyword_1_2() { return cShouldKeyword_1_2; }
		
		//main=Main
		public Assignment getMainAssignment_1_3() { return cMainAssignment_1_3; }
		
		//Main
		public RuleCall getMainMainParserRuleCall_1_3_0() { return cMainMainParserRuleCall_1_3_0; }
		
		//ParagraphDelimiter
		public RuleCall getParagraphDelimiterParserRuleCall_1_4() { return cParagraphDelimiterParserRuleCall_1_4; }
		
		//(listeners+=EventListener (ParagraphDelimiter listeners+=EventListener)* '.')?
		public Group getGroup_2() { return cGroup_2; }
		
		//listeners+=EventListener
		public Assignment getListenersAssignment_2_0() { return cListenersAssignment_2_0; }
		
		//EventListener
		public RuleCall getListenersEventListenerParserRuleCall_2_0_0() { return cListenersEventListenerParserRuleCall_2_0_0; }
		
		//(ParagraphDelimiter listeners+=EventListener)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//ParagraphDelimiter
		public RuleCall getParagraphDelimiterParserRuleCall_2_1_0() { return cParagraphDelimiterParserRuleCall_2_1_0; }
		
		//listeners+=EventListener
		public Assignment getListenersAssignment_2_1_1() { return cListenersAssignment_2_1_1; }
		
		//EventListener
		public RuleCall getListenersEventListenerParserRuleCall_2_1_1_0() { return cListenersEventListenerParserRuleCall_2_1_1_0; }
		
		//'.'
		public Keyword getFullStopKeyword_2_2() { return cFullStopKeyword_2_2; }
	}
	public class MainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.Main");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cActionsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cActionsActionParserRuleCall_0_0 = (RuleCall)cActionsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cActionDelimiterParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cActionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cActionsActionParserRuleCall_1_1_0 = (RuleCall)cActionsAssignment_1_1.eContents().get(0);
		
		//Main:
		//	actions+=Action (ActionDelimiter actions+=Action)*;
		@Override public ParserRule getRule() { return rule; }
		
		//actions+=Action (ActionDelimiter actions+=Action)*
		public Group getGroup() { return cGroup; }
		
		//actions+=Action
		public Assignment getActionsAssignment_0() { return cActionsAssignment_0; }
		
		//Action
		public RuleCall getActionsActionParserRuleCall_0_0() { return cActionsActionParserRuleCall_0_0; }
		
		//(ActionDelimiter actions+=Action)*
		public Group getGroup_1() { return cGroup_1; }
		
		//ActionDelimiter
		public RuleCall getActionDelimiterParserRuleCall_1_0() { return cActionDelimiterParserRuleCall_1_0; }
		
		//actions+=Action
		public Assignment getActionsAssignment_1_1() { return cActionsAssignment_1_1; }
		
		//Action
		public RuleCall getActionsActionParserRuleCall_1_1_0() { return cActionsActionParserRuleCall_1_1_0; }
	}
	public class EventListenerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.EventListener");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cWhenKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cWhenKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cItKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEventAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEventEventParserRuleCall_2_0 = (RuleCall)cEventAssignment_2.eContents().get(0);
		private final Keyword cItKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cShouldKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cActionsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cActionsActionParserRuleCall_5_0 = (RuleCall)cActionsAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final RuleCall cActionDelimiterParserRuleCall_6_0 = (RuleCall)cGroup_6.eContents().get(0);
		private final Assignment cActionsAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cActionsActionParserRuleCall_6_1_0 = (RuleCall)cActionsAssignment_6_1.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cLeftParenthesisKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Keyword cButKeyword_7_1 = (Keyword)cGroup_7.eContents().get(1);
		private final Assignment cSublistenersAssignment_7_2 = (Assignment)cGroup_7.eContents().get(2);
		private final RuleCall cSublistenersEventListenerParserRuleCall_7_2_0 = (RuleCall)cSublistenersAssignment_7_2.eContents().get(0);
		private final Group cGroup_7_3 = (Group)cGroup_7.eContents().get(3);
		private final RuleCall cSublistenerDelimiterParserRuleCall_7_3_0 = (RuleCall)cGroup_7_3.eContents().get(0);
		private final Assignment cSublistenersAssignment_7_3_1 = (Assignment)cGroup_7_3.eContents().get(1);
		private final RuleCall cSublistenersEventListenerParserRuleCall_7_3_1_0 = (RuleCall)cSublistenersAssignment_7_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7_4 = (Keyword)cGroup_7.eContents().get(4);
		
		//EventListener:
		//	('When' | 'when') 'it' event=Event 'it' 'should'
		//	actions+=Action (ActionDelimiter actions+=Action)* ('(' 'but' sublisteners+=EventListener (SublistenerDelimiter
		//	sublisteners+=EventListener)* ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//('When' | 'when') 'it' event=Event 'it' 'should' actions+=Action (ActionDelimiter actions+=Action)* ('(' 'but'
		//sublisteners+=EventListener (SublistenerDelimiter sublisteners+=EventListener)* ')')?
		public Group getGroup() { return cGroup; }
		
		//'When' | 'when'
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'When'
		public Keyword getWhenKeyword_0_0() { return cWhenKeyword_0_0; }
		
		//'when'
		public Keyword getWhenKeyword_0_1() { return cWhenKeyword_0_1; }
		
		//'it'
		public Keyword getItKeyword_1() { return cItKeyword_1; }
		
		//event=Event
		public Assignment getEventAssignment_2() { return cEventAssignment_2; }
		
		//Event
		public RuleCall getEventEventParserRuleCall_2_0() { return cEventEventParserRuleCall_2_0; }
		
		//'it'
		public Keyword getItKeyword_3() { return cItKeyword_3; }
		
		//'should'
		public Keyword getShouldKeyword_4() { return cShouldKeyword_4; }
		
		//actions+=Action
		public Assignment getActionsAssignment_5() { return cActionsAssignment_5; }
		
		//Action
		public RuleCall getActionsActionParserRuleCall_5_0() { return cActionsActionParserRuleCall_5_0; }
		
		//(ActionDelimiter actions+=Action)*
		public Group getGroup_6() { return cGroup_6; }
		
		//ActionDelimiter
		public RuleCall getActionDelimiterParserRuleCall_6_0() { return cActionDelimiterParserRuleCall_6_0; }
		
		//actions+=Action
		public Assignment getActionsAssignment_6_1() { return cActionsAssignment_6_1; }
		
		//Action
		public RuleCall getActionsActionParserRuleCall_6_1_0() { return cActionsActionParserRuleCall_6_1_0; }
		
		//('(' 'but' sublisteners+=EventListener (SublistenerDelimiter sublisteners+=EventListener)* ')')?
		public Group getGroup_7() { return cGroup_7; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_7_0() { return cLeftParenthesisKeyword_7_0; }
		
		//'but'
		public Keyword getButKeyword_7_1() { return cButKeyword_7_1; }
		
		//sublisteners+=EventListener
		public Assignment getSublistenersAssignment_7_2() { return cSublistenersAssignment_7_2; }
		
		//EventListener
		public RuleCall getSublistenersEventListenerParserRuleCall_7_2_0() { return cSublistenersEventListenerParserRuleCall_7_2_0; }
		
		//(SublistenerDelimiter sublisteners+=EventListener)*
		public Group getGroup_7_3() { return cGroup_7_3; }
		
		//SublistenerDelimiter
		public RuleCall getSublistenerDelimiterParserRuleCall_7_3_0() { return cSublistenerDelimiterParserRuleCall_7_3_0; }
		
		//sublisteners+=EventListener
		public Assignment getSublistenersAssignment_7_3_1() { return cSublistenersAssignment_7_3_1; }
		
		//EventListener
		public RuleCall getSublistenersEventListenerParserRuleCall_7_3_1_0() { return cSublistenersEventListenerParserRuleCall_7_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_7_4() { return cRightParenthesisKeyword_7_4; }
	}
	public class SublistenerDelimiterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.SublistenerDelimiter");
		private final Keyword cFullStopKeyword = (Keyword)rule.eContents().get(1);
		
		//SublistenerDelimiter:
		//	'.';
		@Override public ParserRule getRule() { return rule; }
		
		//'.'
		public Keyword getFullStopKeyword() { return cFullStopKeyword; }
	}
	public class ActionDelimiterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.ActionDelimiter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Keyword cAndKeyword_0_0_0 = (Keyword)cGroup_0_0.eContents().get(0);
		private final Keyword cThenKeyword_0_0_1 = (Keyword)cGroup_0_0.eContents().get(1);
		private final Group cGroup_0_1 = (Group)cAlternatives_0.eContents().get(1);
		private final Keyword cCommaKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Keyword cThenKeyword_0_1_1 = (Keyword)cGroup_0_1.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cAlternatives_0.eContents().get(2);
		private final Keyword cFullStopKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Keyword cThenKeyword_0_2_1 = (Keyword)cGroup_0_2.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cItKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cShouldKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//ActionDelimiter:
		//	("and" "then" | "," "then" | "." "Then") ("it" "should")?;
		@Override public ParserRule getRule() { return rule; }
		
		//("and" "then" | "," "then" | "." "Then") ("it" "should")?
		public Group getGroup() { return cGroup; }
		
		//"and" "then" | "," "then" | "." "Then"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//"and" "then"
		public Group getGroup_0_0() { return cGroup_0_0; }
		
		//"and"
		public Keyword getAndKeyword_0_0_0() { return cAndKeyword_0_0_0; }
		
		//"then"
		public Keyword getThenKeyword_0_0_1() { return cThenKeyword_0_0_1; }
		
		//"," "then"
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//","
		public Keyword getCommaKeyword_0_1_0() { return cCommaKeyword_0_1_0; }
		
		//"then"
		public Keyword getThenKeyword_0_1_1() { return cThenKeyword_0_1_1; }
		
		//"." "Then"
		public Group getGroup_0_2() { return cGroup_0_2; }
		
		//"."
		public Keyword getFullStopKeyword_0_2_0() { return cFullStopKeyword_0_2_0; }
		
		//"Then"
		public Keyword getThenKeyword_0_2_1() { return cThenKeyword_0_2_1; }
		
		//("it" "should")?
		public Group getGroup_1() { return cGroup_1; }
		
		//"it"
		public Keyword getItKeyword_1_0() { return cItKeyword_1_0; }
		
		//"should"
		public Keyword getShouldKeyword_1_1() { return cShouldKeyword_1_1; }
	}
	public class ParagraphDelimiterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.ParagraphDelimiter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cNEWLINETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cNEWLINETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//ParagraphDelimiter:
		//	'.' NEWLINE NEWLINE+;
		@Override public ParserRule getRule() { return rule; }
		
		//'.' NEWLINE NEWLINE+
		public Group getGroup() { return cGroup; }
		
		//'.'
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }
		
		//NEWLINE
		public RuleCall getNEWLINETerminalRuleCall_1() { return cNEWLINETerminalRuleCall_1; }
		
		//NEWLINE+
		public RuleCall getNEWLINETerminalRuleCall_2() { return cNEWLINETerminalRuleCall_2; }
	}
	public class ActionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.Action");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMoveParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTurnParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cStopParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Action:
		//	Move | Turn | Stop;
		@Override public ParserRule getRule() { return rule; }
		
		//Move | Turn | Stop
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Move
		public RuleCall getMoveParserRuleCall_0() { return cMoveParserRuleCall_0; }
		
		//Turn
		public RuleCall getTurnParserRuleCall_1() { return cTurnParserRuleCall_1; }
		
		//Stop
		public RuleCall getStopParserRuleCall_2() { return cStopParserRuleCall_2; }
	}
	public class EventElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.Event");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cObstacleParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTappedParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Event:
		//	Obstacle | Tapped;
		@Override public ParserRule getRule() { return rule; }
		
		//Obstacle | Tapped
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Obstacle
		public RuleCall getObstacleParserRuleCall_0() { return cObstacleParserRuleCall_0; }
		
		//Tapped
		public RuleCall getTappedParserRuleCall_1() { return cTappedParserRuleCall_1; }
	}
	public class MoveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.Move");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cMoveAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cMoveKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDirectionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDirectionMOVE_DIRECTIONEnumRuleCall_2_0 = (RuleCall)cDirectionAssignment_2.eContents().get(0);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cAlternatives_3.eContents().get(0);
		private final Keyword cForKeyword_3_0_0 = (Keyword)cGroup_3_0.eContents().get(0);
		private final Assignment cDurationAssignment_3_0_1 = (Assignment)cGroup_3_0.eContents().get(1);
		private final RuleCall cDurationEFloatParserRuleCall_3_0_1_0 = (RuleCall)cDurationAssignment_3_0_1.eContents().get(0);
		private final Keyword cSecondsKeyword_3_0_2 = (Keyword)cGroup_3_0.eContents().get(2);
		private final Assignment cIsRandomAssignment_3_1 = (Assignment)cAlternatives_3.eContents().get(1);
		private final RuleCall cIsRandomRANDOMEnumRuleCall_3_1_0 = (RuleCall)cIsRandomAssignment_3_1.eContents().get(0);
		
		//Move:
		//	{Move}
		//	'move' direction=MOVE_DIRECTION? ('for' duration=EFloat 'seconds' | isRandom=RANDOM)?;
		@Override public ParserRule getRule() { return rule; }
		
		//{Move} 'move' direction=MOVE_DIRECTION? ('for' duration=EFloat 'seconds' | isRandom=RANDOM)?
		public Group getGroup() { return cGroup; }
		
		//{Move}
		public Action getMoveAction_0() { return cMoveAction_0; }
		
		//'move'
		public Keyword getMoveKeyword_1() { return cMoveKeyword_1; }
		
		//direction=MOVE_DIRECTION?
		public Assignment getDirectionAssignment_2() { return cDirectionAssignment_2; }
		
		//MOVE_DIRECTION
		public RuleCall getDirectionMOVE_DIRECTIONEnumRuleCall_2_0() { return cDirectionMOVE_DIRECTIONEnumRuleCall_2_0; }
		
		//('for' duration=EFloat 'seconds' | isRandom=RANDOM)?
		public Alternatives getAlternatives_3() { return cAlternatives_3; }
		
		//'for' duration=EFloat 'seconds'
		public Group getGroup_3_0() { return cGroup_3_0; }
		
		//'for'
		public Keyword getForKeyword_3_0_0() { return cForKeyword_3_0_0; }
		
		//duration=EFloat
		public Assignment getDurationAssignment_3_0_1() { return cDurationAssignment_3_0_1; }
		
		//EFloat
		public RuleCall getDurationEFloatParserRuleCall_3_0_1_0() { return cDurationEFloatParserRuleCall_3_0_1_0; }
		
		//'seconds'
		public Keyword getSecondsKeyword_3_0_2() { return cSecondsKeyword_3_0_2; }
		
		//isRandom=RANDOM
		public Assignment getIsRandomAssignment_3_1() { return cIsRandomAssignment_3_1; }
		
		//RANDOM
		public RuleCall getIsRandomRANDOMEnumRuleCall_3_1_0() { return cIsRandomRANDOMEnumRuleCall_3_1_0; }
	}
	public class TurnElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.Turn");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTurnAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTurnKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDirectionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDirectionTURN_DIRECTIONEnumRuleCall_2_0 = (RuleCall)cDirectionAssignment_2.eContents().get(0);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cAlternatives_3.eContents().get(0);
		private final Keyword cForKeyword_3_0_0 = (Keyword)cGroup_3_0.eContents().get(0);
		private final Assignment cDurationAssignment_3_0_1 = (Assignment)cGroup_3_0.eContents().get(1);
		private final RuleCall cDurationEFloatParserRuleCall_3_0_1_0 = (RuleCall)cDurationAssignment_3_0_1.eContents().get(0);
		private final Keyword cSecondsKeyword_3_0_2 = (Keyword)cGroup_3_0.eContents().get(2);
		private final Group cGroup_3_1 = (Group)cAlternatives_3.eContents().get(1);
		private final Assignment cDegreesAssignment_3_1_0 = (Assignment)cGroup_3_1.eContents().get(0);
		private final RuleCall cDegreesEFloatParserRuleCall_3_1_0_0 = (RuleCall)cDegreesAssignment_3_1_0.eContents().get(0);
		private final Keyword cDegreesKeyword_3_1_1 = (Keyword)cGroup_3_1.eContents().get(1);
		private final Assignment cIsRandomAssignment_3_2 = (Assignment)cAlternatives_3.eContents().get(2);
		private final RuleCall cIsRandomRANDOMEnumRuleCall_3_2_0 = (RuleCall)cIsRandomAssignment_3_2.eContents().get(0);
		
		//Turn:
		//	{Turn}
		//	'turn' direction=TURN_DIRECTION? ('for' duration=EFloat 'seconds' | degrees=EFloat 'degrees' | isRandom=RANDOM)?;
		@Override public ParserRule getRule() { return rule; }
		
		//{Turn} 'turn' direction=TURN_DIRECTION? ('for' duration=EFloat 'seconds' | degrees=EFloat 'degrees' | isRandom=RANDOM)?
		public Group getGroup() { return cGroup; }
		
		//{Turn}
		public Action getTurnAction_0() { return cTurnAction_0; }
		
		//'turn'
		public Keyword getTurnKeyword_1() { return cTurnKeyword_1; }
		
		//direction=TURN_DIRECTION?
		public Assignment getDirectionAssignment_2() { return cDirectionAssignment_2; }
		
		//TURN_DIRECTION
		public RuleCall getDirectionTURN_DIRECTIONEnumRuleCall_2_0() { return cDirectionTURN_DIRECTIONEnumRuleCall_2_0; }
		
		//('for' duration=EFloat 'seconds' | degrees=EFloat 'degrees' | isRandom=RANDOM)?
		public Alternatives getAlternatives_3() { return cAlternatives_3; }
		
		//'for' duration=EFloat 'seconds'
		public Group getGroup_3_0() { return cGroup_3_0; }
		
		//'for'
		public Keyword getForKeyword_3_0_0() { return cForKeyword_3_0_0; }
		
		//duration=EFloat
		public Assignment getDurationAssignment_3_0_1() { return cDurationAssignment_3_0_1; }
		
		//EFloat
		public RuleCall getDurationEFloatParserRuleCall_3_0_1_0() { return cDurationEFloatParserRuleCall_3_0_1_0; }
		
		//'seconds'
		public Keyword getSecondsKeyword_3_0_2() { return cSecondsKeyword_3_0_2; }
		
		//degrees=EFloat 'degrees'
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//degrees=EFloat
		public Assignment getDegreesAssignment_3_1_0() { return cDegreesAssignment_3_1_0; }
		
		//EFloat
		public RuleCall getDegreesEFloatParserRuleCall_3_1_0_0() { return cDegreesEFloatParserRuleCall_3_1_0_0; }
		
		//'degrees'
		public Keyword getDegreesKeyword_3_1_1() { return cDegreesKeyword_3_1_1; }
		
		//isRandom=RANDOM
		public Assignment getIsRandomAssignment_3_2() { return cIsRandomAssignment_3_2; }
		
		//RANDOM
		public RuleCall getIsRandomRANDOMEnumRuleCall_3_2_0() { return cIsRandomRANDOMEnumRuleCall_3_2_0; }
	}
	public class StopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.Stop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStopAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cForKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cDurationAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cDurationEFloatParserRuleCall_2_1_0 = (RuleCall)cDurationAssignment_2_1.eContents().get(0);
		private final Keyword cSecondsKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//Stop:
		//	{Stop}
		//	'stop' ('for' duration=EFloat 'seconds')?;
		@Override public ParserRule getRule() { return rule; }
		
		//{Stop} 'stop' ('for' duration=EFloat 'seconds')?
		public Group getGroup() { return cGroup; }
		
		//{Stop}
		public Action getStopAction_0() { return cStopAction_0; }
		
		//'stop'
		public Keyword getStopKeyword_1() { return cStopKeyword_1; }
		
		//('for' duration=EFloat 'seconds')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'for'
		public Keyword getForKeyword_2_0() { return cForKeyword_2_0; }
		
		//duration=EFloat
		public Assignment getDurationAssignment_2_1() { return cDurationAssignment_2_1; }
		
		//EFloat
		public RuleCall getDurationEFloatParserRuleCall_2_1_0() { return cDurationEFloatParserRuleCall_2_1_0; }
		
		//'seconds'
		public Keyword getSecondsKeyword_2_2() { return cSecondsKeyword_2_2; }
	}
	public class EFloatElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.EFloat");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cINTTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Alternatives cAlternatives_4_0 = (Alternatives)cGroup_4.eContents().get(0);
		private final Keyword cEKeyword_4_0_0 = (Keyword)cAlternatives_4_0.eContents().get(0);
		private final Keyword cEKeyword_4_0_1 = (Keyword)cAlternatives_4_0.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_4_2 = (RuleCall)cGroup_4.eContents().get(2);
		
		//EFloat ecore::EFloat:
		//	'-'? INT? '.'? INT (('E' | 'e') '-'? INT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//'-'? INT? '.'? INT (('E' | 'e') '-'? INT)?
		public Group getGroup() { return cGroup; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//INT?
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
		
		//'.'?
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_3() { return cINTTerminalRuleCall_3; }
		
		//(('E' | 'e') '-'? INT)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'E' | 'e'
		public Alternatives getAlternatives_4_0() { return cAlternatives_4_0; }
		
		//'E'
		public Keyword getEKeyword_4_0_0() { return cEKeyword_4_0_0; }
		
		//'e'
		public Keyword getEKeyword_4_0_1() { return cEKeyword_4_0_1; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_4_1() { return cHyphenMinusKeyword_4_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_4_2() { return cINTTerminalRuleCall_4_2; }
	}
	public class EBooleanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.EBoolean");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//EBoolean ecore::EBoolean:
		//	'true' | 'false';
		@Override public ParserRule getRule() { return rule; }
		
		//'true' | 'false'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'true'
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }
		
		//'false'
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}
	public class EStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.EString");
		private final RuleCall cSTRINGTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//EString:
		//	STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//STRING
		public RuleCall getSTRINGTerminalRuleCall() { return cSTRINGTerminalRuleCall; }
	}
	public class ObstacleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.Obstacle");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cObstacleAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cMeetsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cAnKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cObstacleKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Obstacle:
		//	{Obstacle}
		//	'meets' 'an' 'obstacle';
		@Override public ParserRule getRule() { return rule; }
		
		//{Obstacle} 'meets' 'an' 'obstacle'
		public Group getGroup() { return cGroup; }
		
		//{Obstacle}
		public Action getObstacleAction_0() { return cObstacleAction_0; }
		
		//'meets'
		public Keyword getMeetsKeyword_1() { return cMeetsKeyword_1; }
		
		//'an'
		public Keyword getAnKeyword_2() { return cAnKeyword_2; }
		
		//'obstacle'
		public Keyword getObstacleKeyword_3() { return cObstacleKeyword_3; }
	}
	public class TappedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.Tapped");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTappedAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cTappedKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Tapped:
		//	{Tapped}
		//	'is' 'tapped';
		@Override public ParserRule getRule() { return rule; }
		
		//{Tapped} 'is' 'tapped'
		public Group getGroup() { return cGroup; }
		
		//{Tapped}
		public Action getTappedAction_0() { return cTappedAction_0; }
		
		//'is'
		public Keyword getIsKeyword_1() { return cIsKeyword_1; }
		
		//'tapped'
		public Keyword getTappedKeyword_2() { return cTappedKeyword_2; }
	}
	
	public class MOVE_DIRECTIONElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.MOVE_DIRECTION");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cFORWARDSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cFORWARDSForwardsKeyword_0_0 = (Keyword)cFORWARDSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cFORWARDSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cFORWARDSForwardKeyword_1_0 = (Keyword)cFORWARDSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cBACKWARDSEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cBACKWARDSBackwardsKeyword_2_0 = (Keyword)cBACKWARDSEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cBACKWARDSEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cBACKWARDSBackwardKeyword_3_0 = (Keyword)cBACKWARDSEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cBACKWARDSEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cBACKWARDSBackKeyword_4_0 = (Keyword)cBACKWARDSEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum MOVE_DIRECTION:
		//	FORWARDS='forwards' | FORWARDS='forward' | BACKWARDS='backwards' | BACKWARDS='backward' | BACKWARDS='back';
		public EnumRule getRule() { return rule; }
		
		//FORWARDS='forwards' | FORWARDS='forward' | BACKWARDS='backwards' | BACKWARDS='backward' | BACKWARDS='back'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//FORWARDS='forwards'
		public EnumLiteralDeclaration getFORWARDSEnumLiteralDeclaration_0() { return cFORWARDSEnumLiteralDeclaration_0; }
		
		//'forwards'
		public Keyword getFORWARDSForwardsKeyword_0_0() { return cFORWARDSForwardsKeyword_0_0; }
		
		//FORWARDS='forward'
		public EnumLiteralDeclaration getFORWARDSEnumLiteralDeclaration_1() { return cFORWARDSEnumLiteralDeclaration_1; }
		
		//'forward'
		public Keyword getFORWARDSForwardKeyword_1_0() { return cFORWARDSForwardKeyword_1_0; }
		
		//BACKWARDS='backwards'
		public EnumLiteralDeclaration getBACKWARDSEnumLiteralDeclaration_2() { return cBACKWARDSEnumLiteralDeclaration_2; }
		
		//'backwards'
		public Keyword getBACKWARDSBackwardsKeyword_2_0() { return cBACKWARDSBackwardsKeyword_2_0; }
		
		//BACKWARDS='backward'
		public EnumLiteralDeclaration getBACKWARDSEnumLiteralDeclaration_3() { return cBACKWARDSEnumLiteralDeclaration_3; }
		
		//'backward'
		public Keyword getBACKWARDSBackwardKeyword_3_0() { return cBACKWARDSBackwardKeyword_3_0; }
		
		//BACKWARDS='back'
		public EnumLiteralDeclaration getBACKWARDSEnumLiteralDeclaration_4() { return cBACKWARDSEnumLiteralDeclaration_4; }
		
		//'back'
		public Keyword getBACKWARDSBackKeyword_4_0() { return cBACKWARDSBackKeyword_4_0; }
	}
	public class TURN_DIRECTIONElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.TURN_DIRECTION");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLEFTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLEFTLeftKeyword_0_0 = (Keyword)cLEFTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cRIGHTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cRIGHTRightKeyword_1_0 = (Keyword)cRIGHTEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum TURN_DIRECTION:
		//	LEFT='left' | RIGHT='right';
		public EnumRule getRule() { return rule; }
		
		//LEFT='left' | RIGHT='right'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//LEFT='left'
		public EnumLiteralDeclaration getLEFTEnumLiteralDeclaration_0() { return cLEFTEnumLiteralDeclaration_0; }
		
		//'left'
		public Keyword getLEFTLeftKeyword_0_0() { return cLEFTLeftKeyword_0_0; }
		
		//RIGHT='right'
		public EnumLiteralDeclaration getRIGHTEnumLiteralDeclaration_1() { return cRIGHTEnumLiteralDeclaration_1; }
		
		//'right'
		public Keyword getRIGHTRightKeyword_1_0() { return cRIGHTRightKeyword_1_0; }
	}
	public class RANDOMElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.RANDOM");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cRANDOMEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cRANDOMRandomlyKeyword_0_0 = (Keyword)cRANDOMEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cRANDOMEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cRANDOMRandomKeyword_1_0 = (Keyword)cRANDOMEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum RANDOM:
		//	RANDOM='randomly' | RANDOM='random';
		public EnumRule getRule() { return rule; }
		
		//RANDOM='randomly' | RANDOM='random'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//RANDOM='randomly'
		public EnumLiteralDeclaration getRANDOMEnumLiteralDeclaration_0() { return cRANDOMEnumLiteralDeclaration_0; }
		
		//'randomly'
		public Keyword getRANDOMRandomlyKeyword_0_0() { return cRANDOMRandomlyKeyword_0_0; }
		
		//RANDOM='random'
		public EnumLiteralDeclaration getRANDOMEnumLiteralDeclaration_1() { return cRANDOMEnumLiteralDeclaration_1; }
		
		//'random'
		public Keyword getRANDOMRandomKeyword_1_0() { return cRANDOMRandomKeyword_1_0; }
	}
	
	private final RoboProseElements pRoboProse;
	private final MainElements pMain;
	private final EventListenerElements pEventListener;
	private final SublistenerDelimiterElements pSublistenerDelimiter;
	private final TerminalRule tWS;
	private final TerminalRule tNEWLINE;
	private final ActionDelimiterElements pActionDelimiter;
	private final ParagraphDelimiterElements pParagraphDelimiter;
	private final ActionElements pAction;
	private final EventElements pEvent;
	private final MoveElements pMove;
	private final TurnElements pTurn;
	private final StopElements pStop;
	private final EFloatElements pEFloat;
	private final EBooleanElements pEBoolean;
	private final EStringElements pEString;
	private final ObstacleElements pObstacle;
	private final TappedElements pTapped;
	private final MOVE_DIRECTIONElements eMOVE_DIRECTION;
	private final TURN_DIRECTIONElements eTURN_DIRECTION;
	private final RANDOMElements eRANDOM;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public RoboProseGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pRoboProse = new RoboProseElements();
		this.pMain = new MainElements();
		this.pEventListener = new EventListenerElements();
		this.pSublistenerDelimiter = new SublistenerDelimiterElements();
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.WS");
		this.tNEWLINE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "dk.itu.dsl.roboprose.RoboProse.NEWLINE");
		this.pActionDelimiter = new ActionDelimiterElements();
		this.pParagraphDelimiter = new ParagraphDelimiterElements();
		this.pAction = new ActionElements();
		this.pEvent = new EventElements();
		this.pMove = new MoveElements();
		this.pTurn = new TurnElements();
		this.pStop = new StopElements();
		this.pEFloat = new EFloatElements();
		this.pEBoolean = new EBooleanElements();
		this.pEString = new EStringElements();
		this.pObstacle = new ObstacleElements();
		this.pTapped = new TappedElements();
		this.eMOVE_DIRECTION = new MOVE_DIRECTIONElements();
		this.eTURN_DIRECTION = new TURN_DIRECTIONElements();
		this.eRANDOM = new RANDOMElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("dk.itu.dsl.roboprose.RoboProse".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//RoboProse:
	//	{RoboProse} ('My' 'robot' 'should' main=Main ParagraphDelimiter)? (listeners+=EventListener (ParagraphDelimiter
	//	listeners+=EventListener)* '.')?;
	public RoboProseElements getRoboProseAccess() {
		return pRoboProse;
	}
	
	public ParserRule getRoboProseRule() {
		return getRoboProseAccess().getRule();
	}
	
	//Main:
	//	actions+=Action (ActionDelimiter actions+=Action)*;
	public MainElements getMainAccess() {
		return pMain;
	}
	
	public ParserRule getMainRule() {
		return getMainAccess().getRule();
	}
	
	//EventListener:
	//	('When' | 'when') 'it' event=Event 'it' 'should'
	//	actions+=Action (ActionDelimiter actions+=Action)* ('(' 'but' sublisteners+=EventListener (SublistenerDelimiter
	//	sublisteners+=EventListener)* ')')?;
	public EventListenerElements getEventListenerAccess() {
		return pEventListener;
	}
	
	public ParserRule getEventListenerRule() {
		return getEventListenerAccess().getRule();
	}
	
	//SublistenerDelimiter:
	//	'.';
	public SublistenerDelimiterElements getSublistenerDelimiterAccess() {
		return pSublistenerDelimiter;
	}
	
	public ParserRule getSublistenerDelimiterRule() {
		return getSublistenerDelimiterAccess().getRule();
	}
	
	//@ Override terminal WS:
	//	(' ' | '\t')+ NEWLINE?;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//terminal NEWLINE:
	//	'\r'? '\n';
	public TerminalRule getNEWLINERule() {
		return tNEWLINE;
	}
	
	//ActionDelimiter:
	//	("and" "then" | "," "then" | "." "Then") ("it" "should")?;
	public ActionDelimiterElements getActionDelimiterAccess() {
		return pActionDelimiter;
	}
	
	public ParserRule getActionDelimiterRule() {
		return getActionDelimiterAccess().getRule();
	}
	
	//ParagraphDelimiter:
	//	'.' NEWLINE NEWLINE+;
	public ParagraphDelimiterElements getParagraphDelimiterAccess() {
		return pParagraphDelimiter;
	}
	
	public ParserRule getParagraphDelimiterRule() {
		return getParagraphDelimiterAccess().getRule();
	}
	
	//Action:
	//	Move | Turn | Stop;
	public ActionElements getActionAccess() {
		return pAction;
	}
	
	public ParserRule getActionRule() {
		return getActionAccess().getRule();
	}
	
	//Event:
	//	Obstacle | Tapped;
	public EventElements getEventAccess() {
		return pEvent;
	}
	
	public ParserRule getEventRule() {
		return getEventAccess().getRule();
	}
	
	//Move:
	//	{Move}
	//	'move' direction=MOVE_DIRECTION? ('for' duration=EFloat 'seconds' | isRandom=RANDOM)?;
	public MoveElements getMoveAccess() {
		return pMove;
	}
	
	public ParserRule getMoveRule() {
		return getMoveAccess().getRule();
	}
	
	//Turn:
	//	{Turn}
	//	'turn' direction=TURN_DIRECTION? ('for' duration=EFloat 'seconds' | degrees=EFloat 'degrees' | isRandom=RANDOM)?;
	public TurnElements getTurnAccess() {
		return pTurn;
	}
	
	public ParserRule getTurnRule() {
		return getTurnAccess().getRule();
	}
	
	//Stop:
	//	{Stop}
	//	'stop' ('for' duration=EFloat 'seconds')?;
	public StopElements getStopAccess() {
		return pStop;
	}
	
	public ParserRule getStopRule() {
		return getStopAccess().getRule();
	}
	
	//EFloat ecore::EFloat:
	//	'-'? INT? '.'? INT (('E' | 'e') '-'? INT)?;
	public EFloatElements getEFloatAccess() {
		return pEFloat;
	}
	
	public ParserRule getEFloatRule() {
		return getEFloatAccess().getRule();
	}
	
	//EBoolean ecore::EBoolean:
	//	'true' | 'false';
	public EBooleanElements getEBooleanAccess() {
		return pEBoolean;
	}
	
	public ParserRule getEBooleanRule() {
		return getEBooleanAccess().getRule();
	}
	
	//EString:
	//	STRING;
	public EStringElements getEStringAccess() {
		return pEString;
	}
	
	public ParserRule getEStringRule() {
		return getEStringAccess().getRule();
	}
	
	//Obstacle:
	//	{Obstacle}
	//	'meets' 'an' 'obstacle';
	public ObstacleElements getObstacleAccess() {
		return pObstacle;
	}
	
	public ParserRule getObstacleRule() {
		return getObstacleAccess().getRule();
	}
	
	//Tapped:
	//	{Tapped}
	//	'is' 'tapped';
	public TappedElements getTappedAccess() {
		return pTapped;
	}
	
	public ParserRule getTappedRule() {
		return getTappedAccess().getRule();
	}
	
	//enum MOVE_DIRECTION:
	//	FORWARDS='forwards' | FORWARDS='forward' | BACKWARDS='backwards' | BACKWARDS='backward' | BACKWARDS='back';
	public MOVE_DIRECTIONElements getMOVE_DIRECTIONAccess() {
		return eMOVE_DIRECTION;
	}
	
	public EnumRule getMOVE_DIRECTIONRule() {
		return getMOVE_DIRECTIONAccess().getRule();
	}
	
	//enum TURN_DIRECTION:
	//	LEFT='left' | RIGHT='right';
	public TURN_DIRECTIONElements getTURN_DIRECTIONAccess() {
		return eTURN_DIRECTION;
	}
	
	public EnumRule getTURN_DIRECTIONRule() {
		return getTURN_DIRECTIONAccess().getRule();
	}
	
	//enum RANDOM:
	//	RANDOM='randomly' | RANDOM='random';
	public RANDOMElements getRANDOMAccess() {
		return eRANDOM;
	}
	
	public EnumRule getRANDOMRule() {
		return getRANDOMAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
