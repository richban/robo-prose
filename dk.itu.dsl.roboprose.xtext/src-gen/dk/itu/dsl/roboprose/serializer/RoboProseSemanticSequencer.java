/*
 * generated by Xtext 2.12.0
 */
package dk.itu.dsl.roboprose.serializer;

import com.google.inject.Inject;
import dk.itu.dsl.roboprose.model.EventListener;
import dk.itu.dsl.roboprose.model.Main;
import dk.itu.dsl.roboprose.model.Move;
import dk.itu.dsl.roboprose.model.Obstacle;
import dk.itu.dsl.roboprose.model.Repeat;
import dk.itu.dsl.roboprose.model.RoboProse;
import dk.itu.dsl.roboprose.model.RoboprosePackage;
import dk.itu.dsl.roboprose.model.Stop;
import dk.itu.dsl.roboprose.model.Tapped;
import dk.itu.dsl.roboprose.model.Turn;
import dk.itu.dsl.roboprose.services.RoboProseGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class RoboProseSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RoboProseGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RoboprosePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RoboprosePackage.EVENT_LISTENER:
				sequence_EventListener(context, (EventListener) semanticObject); 
				return; 
			case RoboprosePackage.MAIN:
				sequence_Main(context, (Main) semanticObject); 
				return; 
			case RoboprosePackage.MOVE:
				sequence_Move(context, (Move) semanticObject); 
				return; 
			case RoboprosePackage.OBSTACLE:
				sequence_Obstacle(context, (Obstacle) semanticObject); 
				return; 
			case RoboprosePackage.REPEAT:
				sequence_Repeat(context, (Repeat) semanticObject); 
				return; 
			case RoboprosePackage.ROBO_PROSE:
				sequence_RoboProse(context, (RoboProse) semanticObject); 
				return; 
			case RoboprosePackage.STOP:
				sequence_Stop(context, (Stop) semanticObject); 
				return; 
			case RoboprosePackage.TAPPED:
				sequence_Tapped(context, (Tapped) semanticObject); 
				return; 
			case RoboprosePackage.TURN:
				sequence_Turn(context, (Turn) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     EventListener returns EventListener
	 *
	 * Constraint:
	 *     (event=Event actions+=Action actions+=Action* (sublisteners+=EventListener sublisteners+=EventListener*)?)
	 */
	protected void sequence_EventListener(ISerializationContext context, EventListener semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Main returns Main
	 *
	 * Constraint:
	 *     (actions+=Action actions+=Action*)
	 */
	protected void sequence_Main(ISerializationContext context, Main semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Move
	 *     Move returns Move
	 *
	 * Constraint:
	 *     (direction=MOVE_DIRECTION? (duration=EFloat | isRandom=RANDOM)?)
	 */
	protected void sequence_Move(ISerializationContext context, Move semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns Obstacle
	 *     Obstacle returns Obstacle
	 *
	 * Constraint:
	 *     {Obstacle}
	 */
	protected void sequence_Obstacle(ISerializationContext context, Obstacle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Repeat
	 *     Repeat returns Repeat
	 *
	 * Constraint:
	 *     shouldRepeat=SHOULD_REPEAT
	 */
	protected void sequence_Repeat(ISerializationContext context, Repeat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RoboprosePackage.Literals.REPEAT__SHOULD_REPEAT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoboprosePackage.Literals.REPEAT__SHOULD_REPEAT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepeatAccess().getShouldRepeatSHOULD_REPEATEnumRuleCall_1_0(), semanticObject.getShouldRepeat());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RoboProse returns RoboProse
	 *
	 * Constraint:
	 *     (main=Main listeners+=EventListener*)
	 */
	protected void sequence_RoboProse(ISerializationContext context, RoboProse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Stop
	 *     Stop returns Stop
	 *
	 * Constraint:
	 *     duration=EFloat?
	 */
	protected void sequence_Stop(ISerializationContext context, Stop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns Tapped
	 *     Tapped returns Tapped
	 *
	 * Constraint:
	 *     {Tapped}
	 */
	protected void sequence_Tapped(ISerializationContext context, Tapped semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Turn
	 *     Turn returns Turn
	 *
	 * Constraint:
	 *     (direction=TURN_DIRECTION? (duration=EFloat | degrees=EFloat | isRandom=RANDOM)?)
	 */
	protected void sequence_Turn(ISerializationContext context, Turn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
